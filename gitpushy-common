#!/bin/bash

# GitPushy Simple Build and Deployment System
#
# @link http://gitpushy.com
# @author Micon Frink & Friends <frink@frinknet.com>
# @copyright (c) 2013 - FRINKnet and the Expatriated Lemurs of Borneo
# Licenced under the MIT license see - http://lemurs.mit-license.org/

##
# Intialize GitPushy
#
# @usage gitpushy-init
#
gitpushy-init() {
    # set PUSHY variables
    export PUSHY_REPO=""
    export PUSHY_BRANCH=""
    export PUSHY_BRANCHES=()

    # Make sure PUSHY_REPO is set
    [ -z "$PUSHY_REPO" ] && if [ $(git rev-parse --is-bare-repository) = true ]; then
        PUSHY_REPO=$(basename "$PWD")
        PUSHY_REPO=${PUSHY_REPO%.git}
    else
        PUSHY_REPO=$(basename $(readlink -nf "$PWD"/..))
    fi

    while read oldrev newrev refname; do
        PUSHY_BRANCHES+=($(git rev-parse --symbolic --abbrev-ref $refname))
    done

    OFS=$IFS;
    IFS=$'\n'
    PUSHY_BRANCHES=($(sort -u <<<"${PUSHY_BRANCHES[@]}"))
    IFS=$OFS;

    for PUSHY_BRANCH in ${PUSHY_BRANCHES[@]}; do
        gitpushy-push-branch $PUSHY_BRANCH
    done
}

##
# Start a GitPushy Trigger
#
# @usage gitpushy-trigger {trigger}
#
gitpushy-trigger() {
    # check pushy status
    [ $PUSHY_STATUS != 0 ] && return $PUSHY_STATUS

    # prepare pushy config script
    PUSHY_CONFIG="$(gitpushy-script config $1)"
    PUSHY_CUSTOM="$(gitpushy-script custom $1)"
    PUSHY_TRIGGER="$1"

    # return 404 if script doesnt exist
    [ -z "$PUSHY_CONFIG$PUSHY_CUSTOM" ] && return 404

    local IO_OUT=gitpushy-$1-config.output
    local IO_ERR=gitpushy-$1-config.error

    # run config scripts for deployment
    eval "$PUSHY_CONFIG" 1> >(tee $IO_OUT) 2> >(tee $IO_ERR)> >(tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-config - {}")

    # capture exit status
    PUSHY_STATUS=$?
    [ $PUSHY_STATUS = 0 ] && [ -s $IO_ERR ] && PUSHY_STATUS=500

    # set pushy remote vs local
    [ "$PUSHY_SERVER" != "$(hostname)" ] && PUSHY_REMOTE=1

    # setup pushy environment variables
    export PUSHY_ENV="    # $PUSHY_BRANCH $PUSHY_TRIGGER config $(echo; echo "$PUSHY_CONFIG" | tr '\n' '\0' | xargs -0 -I {} echo "    {}")

    # extended environment variables
    PUSHY_BUILD_DIR="$(echo "$PUSHY_BUILD_DIR" | sed 's/^~/$HOME/')"
    PUSHY_STAGE_DIR="$(echo "$PUSHY_STAGE_DIR" | sed 's/^~/$HOME/')"
    PUSHY_DEPLOY_DIR="$(echo "$PUSHY_DEPLOY_DIR" | sed 's/^~/$HOME/')"
    PUSHY_DEPLOY_ARCHIVE="$(echo "$PUSHY_DEPLOY_ARCHIVE" | sed 's/^~/$HOME/')"
    PUSHY_DEPLOY_HOTSWAP='$PUSHY_DEPLOY_HOTSWAP'
    PUSHY_VERBOSE='$PUSHY_VERBOSE'
    PUSHY_SERVER='$PUSHY_SERVER'
    PUSHY_REMOTE='$PUSHY_REMOTE'
    PUSHY_BRANCH='$PUSHY_BRANCH'
    PUSHY_PORT='$PUSHY_PORT'
    PUSHY_USER='$PUSHY_USER'
    PUSHY_REPO='$PUSHY_REPO'
    "

    # show commands run if verbosity is set
    [ $PUSHY_VERBOSE != 0 ] && echo "$PUSHY_CONFIG" | nl -ba | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-config: {}"

    # show environment if verbosity is set
    [ $PUSHY_VERBOSE != 0 ] && echo "$PUSHY_ENV" | nl -ba | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-environment: {}"

    # run deployment scripts
    if [ $PUSHY_STATUS != 0 ]; then
        local DEPLOYMENT_RUN="$1 config"
    elif [ -n "$PUSHY_CUSTOM" ]; then
        local DEPLOYMENT_RUN="$1 custom script"

        local IO_OUT=gitpushy-$1-custom.output
        local IO_ERR=gitpushy-$1-custom.error

        # show commands run if verbosity is set
        [ $PUSHY_VERBOSE != 0 ] && echo "$PUSHY_CUSTOM" | nl -ba | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-custom: {}"

        echo "GitPushy - Calling $DEPLOYMENT_RUN"
        echo "----------"

        # run custom script
        (eval "$PUSHY_CUSTOM" 1> >(tee $IO_OUT) 2> >(tee $IO_ERR))

        # capture exit status
        PUSHY_STATUS=$?
        [ $PUSHY_STATUS = 0 ] && [ -s $IO_ERR ] && PUSHY_STATUS=500

        sleep 2
        echo "----------"
    elif [ -n "$PUSHY_DEPLOY_DIR" ]; then
        local DEPLOYMENT_RUN="$1 deployment"

        echo "GitPushy - Calling $DEPLOYMENT_RUN"

        gitpushy-build $1
        gitpushy-stage $1
        gitpushy-deploy $1
    else
        local DEPLOYMENT_RUN="$1 config"

        echo "GitPushy - Loaded $1 configuration"

        return;
    fi

    # echo status
    if [ $PUSHY_STATUS = 0 ]; then
        echo "GitPushy - Completed $DEPLOYMENT_RUN"
    else
        echo "GitPushy - Exited $DEPLOYMENT_RUN with status $PUSHY_STATUS"
    fi

    # return pushy status
    return $PUSHY_STATUS
}

##
# Building step of a GitPushy Trigger
#
# @usage gitpushy-build {trigger}
#
gitpushy-build() {
    # check pushy status
    [ $PUSHY_STATUS != 0 ] && return $PUSHY_STATUS

    local IO_CMD=gitpushy-$1-build.command
    local IO_OUT=gitpushy-$1-build.output
    local IO_ERR=gitpushy-$1-build.error

    echo "GitPushy - Building $PUSHY_REPO:$PUSHY_BRANCH at $HOSTNAME:$PUSHY_BUILD_DIR"

    # build rsync command (complex because we honor gitattributes
    PUSHY_SYNC="rsync -a --exclude='.git*' $(gitpushy-cat .gitattributes|grep export-ignore|cut -d' ' -f1|tr '\n' '\0' | xargs -0 -I {} echo "--exclude='{}'" | tr '\n' ' ') --delete"

    local PUSHY_SAME_DIR=""

    [ $PUSHY_REMOTE = 0 ] && [ $PUSHY_BUILD_DIR = $PUSHY_STAGE_DIR ] && PUSHY_SAME_DIR="BUILD"

    # set rsync options
    if [ $PUSHY_REMOTE = 0 ]; then
        # rsync locally
        PUSHY_SYNC="$PUSHY_SYNC "'"$PUSHY_BUILD_DIR/" "$PUSHY_STAGE_DIR/"'
    else
        # rsync remote
        PUSHY_SYNC="$PUSHY_SYNC --rsh='ssh -p$PUSHY_PORT' "'"$PUSHY_BUILD_DIR/"'" '$PUSHY_USER@$PUSHY_SERVER:$PUSHY_STAGE_DIR/'"
    fi
    fi

    # prepare pushy build script
    echo "$PUSHY_ENV" > $IO_CMD
    echo "PUSHY_TRIGGER='$1'" >> $IO_CMD
    echo "PUSHY_STATUS='$PUSHY_STATUS'" >> $IO_CMD
    echo 'cd "$PUSHY_BUILD_DIR" 2>/dev/null' >> $IO_CMD
    echo '[ $? != 0 ] && echo "directory does not exist - $PUSHY_BUILD_DIR" >&2 && exit 404' >> $IO_CMD
    echo "git reset --hard HEAD 1>/dev/null" >> $IO_CMD
    gitpushy-script build $1 >> $IO_CMD

    if [ -z "$PUSHY_SAME_DIR" ]; then
        echo "$PUSHY_SYNC" >> $IO_CMD
    fi

    echo 'exit $PUSHY_STATUS' >> $IO_CMD

    # show commands run if verbosity is set
    [ $PUSHY_VERBOSE != 0 ] && cat $IO_CMD | nl -ba | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-build: {}"

    # run pushy build srcipts
    (cat $IO_CMD | bash) 1> >(tee $IO_OUT) 2> >(tee $IO_ERR) | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-build - {}"

    # capture execution status
    PUSHY_STATUS=${PIPESTATUS[0]}
    [ $PUSHY_STATUS = 0 ] && [ -s $IO_ERR ] && PUSHY_STATUS=500

    # return pushy status
    return $PUSHY_STATUS
}

##
# Staging step of a GitPushy Trigger
#
# @usage gitpushy-stage {trigger}
#
gitpushy-stage() {
    # check pushy status
    [ $PUSHY_STATUS != 0 ] && return $PUSHY_STATUS

    local IO_CMD=gitpushy-$1-stage.command
    local IO_OUT=gitpushy-$1-stage.output
    local IO_ERR=gitpushy-$1-stage.error

    echo "GitPushy - Staging $PUSHY_REPO:$PUSHY_BRANCH in $PUSHY_SERVER:$PUSHY_STAGE_DIR"

    # prepare pushy stage script
    echo "$PUSHY_ENV" > $IO_CMD
    echo "PUSHY_TRIGGER='$1'" >> $IO_CMD
    echo "PUSHY_STATUS='$PUSHY_STATUS'" >> $IO_CMD
    echo 'cd "$PUSHY_STAGE_DIR" 2>/dev/null' >> $IO_CMD
    echo '[ $? != 0 ] && echo "directory does not exist - $PUSHY_STAGE_DIR" >&2 && exit 404' >> $IO_CMD
    gitpushy-script stage $1 >> $IO_CMD
    echo 'exit $PUSHY_STATUS' >> $IO_CMD

    # show commands run if verbosity is set
    [ $PUSHY_VERBOSE != 0 ] && cat $IO_CMD | nl -ba | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-stage: {}"

    # run pushy stage scripts
    if [ $PUSHY_REMOTE = 0 ]; then 
        (cat $IO_CMD | bash) 1> >(tee $IO_OUT) 2> >(tee $IO_ERR) | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-stage - {}"
    else
        (cat $IO_CMD | ssh -p $PUSHY_PORT $PUSHY_USER@$PUSHY_SERVER bash) 1> >(tee $IO_OUT) 2> >(tee $IO_ERR) | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-stage - {}"
    fi

    # capture exit status
    PUSHY_STATUS=${PIPESTATUS[0]}
    [ $PUSHY_STATUS = 0 ] && [ -s $IO_ERR ] && PUSHY_STATUS=500

    # return pushy status
    return $PUSHY_STATUS
}

##
# Deployment step of a GitPushy Trigger
#
# @usage gitpushy-deploy {trigger}
#
gitpushy-deploy() {
    # check pushy status
    [ $PUSHY_STATUS != 0 ] && return $PUSHY_STATUS

    local IO_CMD=gitpushy-$1-deploy.command
    local IO_OUT=gitpushy-$1-deploy.output
    local IO_ERR=gitpushy-$1-deploy.error

    local PUSHY_SAME_DIR=""

    [ $PUSHY_REMOTE = 0 ] && [ $PUSHY_BUILD_DIR = $PUSHY_DEPLOY_DIR ] && PUSHY_SAME_DIR="BUILD"
    [ -z "$PUSHY_SAME_DIR" ] && [ $PUSHY_STAGE_DIR = $PUSHY_DEPLOY_DIR ] && PUSHY_SAME_DIR="STAGE"

    echo "GitPushy - Deploying $PUSHY_REPO:$PUSHY_BRANCH to $PUSHY_SERVER:$PUSHY_DEPLOY_DIR"

    # prepare gitpushy-transact
    echo 'gitpushy-transact() {' >> $IO_CMD
    echo 'cd "$PUSHY_DEPLOY_DIR" 2>/dev/null' >> $IO_CMD
    echo '[ $? != 0 ] && echo "Deployment failed to $PUSHY_DEPLOY_DIR" >&2 && PUSHY_STATUS=404' >> $IO_CMD
    gitpushy-script deploy $1 >> $IO_CMD
    echo '}' >> $IO_CMD

    if [ -z "$PUSHY_SAME_DIR" ]; then
        # prepare gitpushy-setup
        echo 'gitpushy-setup() {' >> $IO_CMD
        echo 'cd "$PUSHY_DEPLOY_DIR" 2>/dev/null' >> $IO_CMD
        echo 'if [ $? != 0 ]; then' >> $IO_CMD
        echo 'echo "Deploying to blank directory: $PUSHY_DEPLOY_DIR"' >> $IO_CMD
        echo 'elif [ -n "$PUSHY_DEPLOY_HOTSWAP" ]; then' >> $IO_CMD
        echo 'OLD_HOTSWAP=$(readlink $PUSHY_DEPLOY_DIR)' >> $IO_CMD
        echo 'elif [ -n "$PUSHY_DEPLOY_ARCHIVE" ]; then' >> $IO_CMD
        echo 'tar czf "$PUSHY_DEPLOY_ARCHIVE.tgz" .' >> $IO_CMD
        echo 'fi' >> $IO_CMD
        echo 'cd "$PUSHY_STAGE_DIR" 2>/dev/null' >> $IO_CMD
        echo '[ $? != 0 ] && echo "No stage directory: $PUSHY_STAGE_DIR" >&2 && exit 404' >> $IO_CMD
        echo 'rsync -a --exclude='gitpushy-*' "$PUSHY_STAGE_DIR/" "$PUSHY_DEPLOY_DIR$PUSHY_DEPLOY_HOTSWAP/" --delete' >> $IO_CMD
        echo 'if [ -n "$PUSHY_DEPLOY_HOTSWAP" ]; then' >> $IO_CMD
        echo 'ln -sfn "$PUSHY_DEPLOY_DIR$PUSHY_DEPLOY_HOTSWAP" "$PUSHY_DEPLOY_DIR"' >> $IO_CMD
        echo 'fi' >> $IO_CMD
        echo '}' >> $IO_CMD

        # prepare gitpushy-rollback
        echo 'gitpushy-rollback() {' >> $IO_CMD
        echo 'if [ -n "$OLD_HOTSWAP" ]; then' >> $IO_CMD
        echo 'echo "Rolling back to previous hot swap $OLD_HOTSWAP"' >> $IO_CMD
        echo 'ln -sfn "$OLD_HOTSWAP" "$PUSHY_DEPLOY_DIR"' >> $IO_CMD
        echo 'gitpushy-transact' >> $IO_CMD
        echo 'elif [ -f "$PUSHY_DEPLOY_ARCHIVE.tgz" ]; then' >> $IO_CMD
        echo 'echo "Rolling back to previous $PUSHY_DEPLOY_ARCHIVE"' >> $IO_CMD
        echo 'rm "$PUSHY_DEPLOY_DIR" 2>/dev/null' >> $IO_CMD
        echo 'mkdir "$PUSHY_DEPLOY_DIR"' >> $IO_CMD
        echo 'cd "$PUSHY_DEPLOY_DIR"' >> $IO_CMD
        echo 'tar xzf "$PUSHY_DEPLOY_ARCHIVE.tgz" .' >> $IO_CMD
        echo 'gitpushy-transact' >> $IO_CMD
        echo 'fi' >> $IO_CMD
        echo '}' >> $IO_CMD
    fi

    #prepare running
    echo "$PUSHY_ENV" >> $IO_CMD
    echo "PUSHY_TRIGGER='$1'" >> $IO_CMD
    echo "PUSHY_STATUS='$PUSHY_STATUS'" >> $IO_CMD

    if [ -n "$PUSHY_SAME_DIR" ]; then
        echo "echo 'Deploying in the $PUSHY_SAME_DIR directory'" >> $IO_CMD
        echo "echo ' - no archiving'" >> $IO_CMD 
        echo "echo ' - no hotswapping'" >> $IO_CMD 
        echo "echo ' - no rollbacks'" >> $IO_CMD 
        echo 'gitpushy-transact' >> $IO_CMD
    else
        echo '[ $PUSHY_STATUS = 0 ] && gitpushy-setup' >> $IO_CMD
        echo '[ $PUSHY_STATUS = 0 ] && gitpushy-transact' >> $IO_CMD
        echo '[ $PUSHY_STATUS != 0 ] && gitpushy_rollback' >> $IO_CMD
    fi

    echo 'exit $PUSHY_STATUS' >> $IO_CMD

    # show commands run if verbosity is set
    [ $PUSHY_VERBOSE != 0 ] && cat $IO_CMD | nl -ba | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-deploy: {}"

    # run pushy deploy scripts
    if [ $PUSHY_REMOTE = 0 ]; then
        (cat $IO_CMD | bash) 1> >(tee $IO_OUT) 2> >(tee $IO_ERR) | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-deploy - {}"
    else
        (cat $IO_CMD | ssh -p $PUSHY_PORT $PUSHY_USER@$PUSHY_SERVER bash) 1> >(tee $IO_OUT) 2> >(tee $IO_ERR) | tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-deploy - {}"
    fi

    # capture exit status
    PUSHY_STATUS=${PIPESTATUS[0]}
    [ $PUSHY_STATUS = 0 ] && [ -s $IO_ERR ] && PUSHY_STATUS=500

    # return pushy status
    return $PUSHY_STATUS
}

##
# Run GitPushy triggers for a given branch
#
# @usage gitpushy-push-branch {branch}
#
gitpushy-push-branch() {
    # Export pushy variables to main environment
    export PUSHY_DEPLOY_HOTSWAP="-$(date +%Y%m%d-%H%M%S)"
    export PUSHY_DEPLOY_ARCHIVE="~/$PUSHY_REPO-$(date +%Y%m%d-%H%M%S)"
    export PUSHY_DEPLOY_DIR=""
    export PUSHY_BUILD_KEEP=""
    export PUSHY_BUILD_DIR="/tmp/pushy-$1-build.$RANDOM$RANDOM"
    export PUSHY_STAGE_DIR="~/pushy-staging-$PUSHY_REPO-$1"
    export PUSHY_VERBOSE=0
    export PUSHY_STATUS=0
    export PUSHY_REMOTE=0
    export PUSHY_BRANCH="$1"
    export PUSHY_SERVER="$HOSTNAME"
    export PUSHY_TRIGGERS=()
    export PUSHY_TRIGGER=""
    export PUSHY_PORT=22
    export PUSHY_USER=$(whoami)
    export PUSHY_REPO="$PUSHY_REPO"

    # check if branch exists
    [ -z "$PUSHY_BRANCH" ] && "BRANCH was not passed to gitpushy-push-branch" && return 1
    [ ! -f $GIT_DIR/refs/heads/$PUSHY_BRANCH ] && echo "$PUSHY_BRANCH does not exist in $PUSHY_REPO" && return 1

    # prepare pushy config script
    PUSHY_CONFIG="$(gitpushy-script config main)"
    PUSHY_CUSTOM="$(gitpushy-script custom main)"

    # check if this branch has gitpushy data
    [ ! -f $GIT_DIR/hooks/gitpushy-$PUSHY_BRANCH-branch ] && [ -z "$PUSHY_CONFIG$PUSHY_CUSTOM" ] && echo "No GitPushy for $PUSHY_REPO:$PUSHY_BRANCH" && return 0

    local IO_OUT=gitpushy-$1-config.output
    local IO_ERR=gitpushy-$1-config.error

    # run config scripts for deployment
    eval "$PUSHY_CONFIG" 1> >(tee $IO_OUT) 2> >(tee $IO_ERR)> >(tr '\n' '\0' | xargs -0 -I {} echo "GitPushy - gitpushy-$1-config - {}")

    # capture exit status
    PUSHY_STATUS=$?
    [ $PUSHY_STATUS = 0 ] && [ -s $IO_ERR ] && PUSHY_STATUS=500

    # remember current repo settings
    local REPO_DIR=$GIT_DIR
    local REPO_BARE=$PWD

    # make a switch to clean local clone
    gitpushy-clone-temp $PUSHY_BUILD_DIR

    [ $? != 0 ] && echo "GitPushy - Failed to clone repo to $PUSHY_BUILD_DIR" >&2 && return $?

    # Process GitPushy Branch Hooks
    if [ -f $REPO_BARE/hooks/gitpushy-$PUSHY_BRANCH-branch ]; then
        echo "GitPushy - Custom GitPushy Hook: pushy-$PUSHY_BRANCH-branch"

        local IO_OUT=gitpushy-$1-branch.output
        local IO_ERR=gitpushy-$1-branch.error

        # run branch hook
        (source $REPO_BARE/hooks/gitpushy-$PUSHY_BRANCH-branch 1> >(tee $IO_OUT) 2> >(tee $IO_ERR))

        # capture exit status
        PUSHY_STATUS=$?
        [ -s $IO_ERR ] && PUSHY_STATUS=500
    else
        # run main trigger
        gitpushy-trigger main

        # loop through addtional triggers
        [ $PUSHY_STATUS = 0 ] && for PUSHY_TRIGGER in ${PUSHY_TRIGGERS[@]}; do
            gitpushy-trigger $PUSHY_TRIGGER
        done
    fi

    # clean up after deploy unless we explicitly keep the dir
    [ -z "$PUSHY_BUILD_KEEP" ] && gitpushy-clean-temp $PUSHY_BUILD_DIR

    # reset git orientation
    export GIT_DIR=$REPO_DIR
    cd $REPO_BARE

    return $PUSHY_STATUS
}

##
# Replicate to another Server
#
# @usage gitpushy-push-replicate {hostname} [ {hostname} ...]
#
gitpushy-push-replicate() {
    [ -z "$1" ] && return 402
    [ "$(gitpushy-committer)" = "GitPushy" ] && return 401

    local SERVER=""

    for SERVER in $@; do
        if gitpushy-server-is-local $SERVER; then
            continue
        elif git status 1>/dev/null 2>/dev/null; then
            echo "GitPushy - Syncronizing $1"

            git remote add $1 ssh://$PUSHY_USER@$1:$PUSHY_PORT/$PUSHY_REPO
            git checkout -b $1 1>/dev/null 2>/dev/null
            git fetch $1 1>/dev/null 2>/dev/null

            if [ $? != 0 ]; then
                echo "GitPushy - Failed to fetch ssh://$PUSHY_USER@$1:$PUSHY_PORT/$PUSHY_REPO"
            elif git merge --no-commit $1/$PUSHY_BRANCH $1 1>/dev/null 2>/dev/null; then
                git commit --author="GitPushy <$PUSHY_USER@$PUSHY_SERVER>" --allow-empty -am "Auto-merged from $1 on $PUSHY_SERVER" 1>/dev/null 2>/dev/null
                git push $1 $1:$PUSHY_BRANCH 1>/dev/null 2>/dev/null

                if [ $? = 0 ]; then
                    echo "GitPushy - Syncronization complete!"
                else
                    echo "GitPushy - Failed syncronize to $1 with status $?"
                fi
            else
                git merge --abort 1>/dev/null 2>/dev/null

                echo "GitPushy - Cannot resolve merge conficts with remote $1 $PUSHY_BRANCH"
            fi

            git checkout $PUSHY_BRANCH 1>/dev/null 2>/dev/null
        fi
    done
}

##
# Create a temp directory with a clone
#
# @usage gitpushy-clone-temp {dir}
#
gitpushy-clone-temp() {
    local CLONE_STATUS=0
    [ -z "$PUSHY_BRANCH" ] && PUSHY_BRANCH=$(gitpushy-branch-name)
    [ -z "$1" ] && echo "GitPushy - No build directory specified" && local CLONE_STATUS=404

    if [ $CLONE_STATUS = 0 ]; then
        if [ ! -d "$1" ]; then
          # make a clean local clone
          git clone . $1 1>/dev/null 2>/dev/null
        fi

        # change to new dir
        cd $1

        echo "Working Dir: $(pwd)"

        # reorient git
        export GIT_DIR=$1/.git

        # check git
        git status 1>/dev/null 2>/dev/null
        CLONE_STATUS=$?
    fi

    if [ $CLONE_STATUS = 0 ]; then
        # update the remote to make sure we have all changes
        git remote update 1>/dev/null 2>/dev/null
        CLONE_STATUS=$?

        # checkout track branch
        git checkout -t origin/$PUSHY_BRANCH 1>/dev/null 2>/dev/null

        [ $CLONE_STATUS != 0 ] && echo "Failed to update remote"
    fi

    if [ $CLONE_STATUS = 0 ]; then
        # checkout branch
        git checkout $PUSHY_BRANCH 1>/dev/null 2>/dev/null
        CLONE_STATUS=$?

        [ $CLONE_STATUS != 0 ] && echo "Failed to checkout $PUSHY_BRANCH"
    fi

    if [ $CLONE_STATUS = 0 ]; then
        # pull the latest changes
        git pull origin $PUSHY_BRANCH 1>/dev/null 2>/dev/null
        CLONE_STATUS=$?

        [ $CLONE_STATUS != 0 ] && echo "Failed to pull $PUSHY_BRANCH"
    fi

    [ $CLONE_STATUS != 0 ] && echo "GitPushy - Exited cloning $1 with status $CLONE_STATUS"

    # return pushy status
    return $CLONE_STATUS
}

##
# Clean a given temp dir and switch back to original call directory
#
# @usage gitpushy-clean-temp {dir}
#
gitpushy-clean-temp() {
    local CLEAN_STATUS=0
    [ -z "$1" ] && echo "GitPushy - No build directory specified" && local CLEAN_STATUS=404
    [ $PUSHY_STATUS != 0 ] && echo "GitPushy - Leaving build directory $1" && return 500

    if [ $CLEAN_STATUS = 0 ]; then
        (rm -rf $1) 1>/dev/null 2>/dev/null

        local CLEAN_STATUS=${PIPESTATUS[0]}

        # switch to clone
        [ -n "$PUSHY_BARE" ] && cd $PUSHY_BARE
    fi

    # echo status
    if [ $CLEAN_STATUS != 0 ]; then
        echo "GitPushy - Exited clean-up $1 with status $CLEAN_STATUS"
    fi

    # return pushy status
    return $CLEAN_STATUS
}

##
# Cat GitPushy dot scripts
#
# @usage gitpushy-script {type} [ {trigger} [ {section} ]]
#
gitpushy-script() {
    [ -z "$PUSHY_BRANCH" ] && PUSHY_BRANCH=$(gitpushy-branch-name)

    gitpushy-cat .gitpushy/common/$1 .gitpushy/$PUSHY_BRANCH/$1

    [ -n "$2" ] && gitpushy-script $2-$1 ${@:3}
}

##
# Cat files(s) from the current branch if they exist
#
# @usage gitpushy-cat {file} [ {file} ...]
#
gitpushy-cat() {
    [ -z "$PUSHY_BRANCH" ] && PUSHY_BRANCH=$(gitpushy-branch-name)

    # cat files in repo
    grep -v "^\s*$" <(for file in $@; do
        git show refs/heads/$PUSHY_BRANCH:$file 2>/dev/null
    done)
}

##
# Echo current branch name
#
# @usage gitpushy-branch-name
#
gitpushy-branch-name() {
    local branch_name=$(git symbolic-ref -q HEAD)

    echo ${branch_name##refs/heads/}
}

##
# Echo most recent committer
#
# @usage gitpushy-committer
#
gitpushy-committer() {
    git log -1|grep -Po "(?<=Author:\s).*(?=\s+\<)"
}

##
# Find the IP of a given server
#
# @usage gitpushy-server-ip {hostname}
#
gitpushy-server-ip() {
    ping -c 1 $1 | grep -Po -m 1 '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}';
}

##
# List local IPs
#
# @usage gitpushy-local-ips
#
gitpushy-local-ips() {
    ifconfig | grep -Po '(?<=addr:)[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
}

##
# Check whether a given string is in an array
#
# @usage gitpushy-in-array {needle} {haystack}
#
gitpushy-in-array() {
    local x

    for x in "${@:2}"; do
        [ "$x" = "$1" ] && return 0
    done

    return 1
}

##
# Checks whether a given server is localhost
#
# @usage gitpushy-server-is-local {hostname}
#
gitpushy-server-is-local() {
    if gitpushy-in-array "$(gitpushy-server-ip $1)" $(gitpushy-local-ips); then
        return 0
    fi

    return 1
}
